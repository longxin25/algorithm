### 堆

   * 堆是一种常用的二叉树衍生结构。

   * 特点：1. 必须是**完全二叉树**   2.其子节点的值均不大于或不小于父节点的值

   * 其中，子节点均小于父节点的堆，节点中的值从上往下逐渐递减，根节点（堆顶）最大，称为**大顶堆/最大堆**。与其特性相反的堆称为**小顶堆/最小堆**。

---

### 代码实现

   * 由于堆满足完全二叉树的特点，在使用数组建立时不会产生大量的空缺，并且仅需要数组下标就能实现节点访问，因此很适合利用数组实现。

    class Heap:
        def __init__(self, capacity) -> None:
            self.data = []
            self.capacity = capacity
            self.count = 0

   * 为了便于计算，我们规定数组下标为 1 的位置是堆顶，根据完全二叉树的特点可以推导出下标为 i 的节点，其左子树的下标值为 2 * i，右子树的下标值为 2 * i + 1。

   * 当堆中发生元素变动时，我们需要额外设计一种方法来使得其重新满足堆的特点，这个过程就叫做**堆化**。

   * 堆化分为自下而上堆化和自上而下堆化。

    # 自下而上堆化
    def Heapify_down(self, i):
        # 从底部开始逐个与父节点比较，若父节点小则进行交换
        while i // 2 > 0 and self.data[i] > self.data[i // 2]:
            self.data[i], self.data[i // 2] = self.data[i // 2], self.data[i]
            i = i // 2
            
    # 自上而下堆化
    def Heapify_up(self, n, i):
        # 左子树
        left = i * 2
        # 右子树
        right = i * 2 + 1
        # 最大元素
        largest = i
        # 左子树存在且更大
        if left <= n and self.data[largest] < self.data[left]:
            # 左子树设为最大元素
            largest = left
        # 右子树存在且更大
        if right <= n and self.data[largest] < self.data[right]:
            # 右子树设为最大元素
            largest = right
        # 没有发生交换，堆化结束
        if largest != i:
            self.data[i], self.data[largest] = self.data[largest], self.data[i]
            self.Heapify_up(self.data, n, largest)
            
   * 堆尾部插入元素实现：

    # 插入元素
    def Insert(self, value):
        if self.count == self.capacity:
            return
        self.count += 1
        self.data[self.count] = value
        # 自下而上堆化
        self.Heapify_down(self.count)
        
   * 删除堆顶元素实现：

    # 移除堆顶元素
    def RemoveMax(self):
        if self.count == 0:
            return -1
        self.data[1] = self.data[self.count]
        self.count -= 1
        self.Heapify_up(self.count, 1)
            
---

### 小结

   1. 堆是完全二叉树，和子节点比，父节点的值更大的堆叫做大顶堆，父节点的值更小的堆叫做小顶堆
   2. 建立堆和应用堆的关键在于能否正确实现堆化过程
            
            
            

