## 冒泡排序

   * 冒泡排序是一种基于交换的排序方法，通过 n 趟“冒泡”过程来实现最终结果的有序。

   * “冒泡”过程：从第一个元素开始，每一个元素与下一个元素两两比较，如果当前元素大于后面的元素，则将当前元素与后一个元素交换（达成了大数在后小数在前的效果），遍历到数组末尾停止。

   * 这样一趟完成之后，一个第 N 大的元素就被放在了数组尾端（N = 趟数，第几趟得到的末尾元素就是第几大元素）。重复 n 次，就实现了整体有序。

---

### 代码实现
   
    def bubble_sort(data):
        length = len(data)
        if length <= 1:
            return
        for i in range(0, length):
            # 该趟冒泡是否发生了数据交换
            swaped = False
            # 开始冒泡，同时范围向前缩减
            for j in range(1, length - i):
                # 前面的数大
                if data[j-1] > data[j]:
                    # 交换
                    data[j], data[j-1] = data[j-1], data[j]
                    swaped = True
            # 当此次冒泡未发生数据交换，则证明数据已有序，退出循环
            if not swaped:
                break

---

### 性能分析

   * 时间复杂度：完成全部元素的排序一共需要 n 趟冒泡，一次冒泡的时间复杂度为 O(n), 因此整体时间复杂度为 O(n²)。

   * 空间复杂度：冒泡排序是基于相邻元素交换的原地排序，没有借助额外空间，因此整体空间复杂度为 O(1)。

---

### 关键点

   1. 通过从后往前缩减冒泡范围来减少无效计算
   2. 通过记录当前冒泡是否发生数据交换来避免后续的无效冒泡过程
   
