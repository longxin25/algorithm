### 快速排序

   * 快速排序也是基于分治思想的排序方法。具体实现思路为：随机选取某一个数作为分区点，将整体数据划分为左右两个分区，左侧分区的值全部小于分区点，右侧分区的值全部大于分区点，之后对于每个分区继续采用相同的处理，直到区间长度为1，则实现整体有序。

   * 实现正确的快速排序方法关键在于分区。

   * 分区：假设选取第一个元素作为分区点，从第二个元素开始遍历，若当前元素小于分区点，则将其和左区间末尾元素交换，同时左区间长度加一，当遍历完毕后，将分区点和左区间末尾元素交换，实现分区的目的。

---

### 代码实现

    def quick_sort(data, low, high):
        if low < high:
            # 分区
            p = partition(data, low, high)
            # 对左右区间分别进行快速排序
            quick_sort(data, low, p-1)
            quick_sort(data, p+1, high)
    
    # 分区方法
    def partition(data, low, high):
        # 分区点的值， 左区间起始下标
        pivot, j = data[low], low
        for i in range(low+1, high+1):
            # 小于分区点的元素通过交换被移动到左区间末尾，同时扩充左区间长度
            if data[i] <= pivot:
                j += 1
                data[j], data[i] = data[i], data[j]
        # 分区点和左区间末尾元素交换位置，实现分区
        data[low], data[j] = data[j], data[low]
        # 返回分区点位置
        return j

---

### 性能分析

   * 时间复杂度：O(nlogn)
   * 空间复杂度：O(1)

---

### 关键点

   1. 原地分区的实现
